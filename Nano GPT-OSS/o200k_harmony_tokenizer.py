# -*- coding: utf-8 -*-
"""o200k_harmony tokenizer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1amTPSKU0a4mdcC-axGQPCKgxCnXssfvx
"""

import tiktoken

o200K_base = tiktoken.get_encoding("o200k_base")

total_tokens = len(o200K_base.token_byte_values())
print(f"Total number of tokens in o200k_base: {total_tokens}")

tokens = o200K_base.token_byte_values()

print("First 50 tokens:")
for i in range(50):
    print(f"{i}: {tokens[i]}")

print("\nLast 50 tokens:")
for i in range(len(tokens) - 50, len(tokens)):
    print(f"{i}: {tokens[i]}")

print(o200K_base._special_tokens)

"""1. üîç Pattern String (pat_str)
The pattern string is a Regular Expression that handles the first stage of tokenization: breaking raw, continuous text into initial, unprocessed segments (tokens).

Role: Segmentation. It defines the basic boundaries‚Äîwhere the model is allowed to split the text.

Input: The raw text string ("Hello world! ").

Output: An initial list of segments (e.g., ["Hello", " ", "world", "!"]).

Analogy: The Scissors. The pattern string is the rule set for cutting the raw stream of text into manageable chunks. It ensures that numbers stay with numbers, punctuation is separated from letters, and spaces are handled explicitly.

2. üìö Mergeable Ranks (_mergeable_ranks)
The mergeable ranks are a large Vocabulary Lookup Table that handles the second stage of tokenization: combining the initial segments into larger, meaningful tokens and assigning them their final integer IDs.

Role: Vocabulary Lookup and Merging. It determines the most efficient way to combine the initial segments based on the BPE rules learned during training, and maps the resulting sequence of bytes to an integer ID.

Input: The initial segments/byte sequences (e.g., the bytes for " Hello").

Output: The final, compressed integer token ID (e.g., 12345).

Analogy: The Dictionary and Glue. The ranks list is the dictionary that says, "I have seen the sequence ' Hello' thousands of times; combine it into token ID 12345." It prioritizes merging common sequences to minimize the final number of tokens.
"""

def get_tokenizer():
    o200K_base = tiktoken.get_encoding("o200k_base")
    tokenizer = tiktoken.Encoding(
        name = "o200k_harmony",
        pat_str = o200K_base._pat_str,
#pat_str is a regular expression (a sequence of characters that defines a search pattern)
#that the tokenizer uses to decide what constitutes a valid chunk of text that can be converted into a token.
        mergeable_ranks = o200K_base._mergeable_ranks,
        special_tokens = {
            **o200K_base._special_tokens,
            "<|startoftext|>": 199998,
            "<|endoftext|>": 199999,
            "<|reserved_200000|>": 200000,
            "<|reserved_200001|>": 200001,
            "<|return|>": 200002,
            "<|constrain|>": 200003,
            "<|reserved_200004|>": 200004,
            "<|channel|>": 200005,
            "<|start|>": 200006,
            "<|end|>": 200007,
            "<|message|>": 200008,
            "<|reserved_200009|>": 200009,
            "<|reserved_200010|>": 200010,
            "<|reserved_200011|>": 200011,
            "<|call|>": 200012,
        } | {
            f"<|reserved_{i}|>": i for i in range(200013, 201088)
        },
    )
    return tokenizer

